# Hippo-Recommendation
# 一、	模型介绍
对于第t期来的顾客，我们观察到他的类型是\bar{h}。
	目标函数：
对第t期推荐的决策以及未来(T-t)期中的所有推荐决策的期望收益。
p_h------类型为h的顾客光顾的概率。

	决策变量：
第t期对每种商品i的推荐的决策x_i;
未来(T-t)期中每一类顾客h对每种商品i推荐的决策x_{ih}。

	约束：
	对第t期来的顾客总的推荐数量不超过K。
	对未来(T-t)期每一类的顾客的总推荐数量不超过K。
	对每种商品i，这一次顾客是否购买与未来（T-t）期中是否被顾客购买的期望总数小于等于库存总数{invent}_i。
	决策变量放松为[0,1]之间的连续变量。
 
通过解以上LP优化问题，我们可以同时得到商品i库存的对偶变量$\gamma_i$ ，对该对偶变量的解释即为商品i库存约束的影子价格。根据这个数值我们可以对商品i更新一个调整的价格(r_i-\gamma_i)。
接着我们对类型为\bar{h}的顾客，对所有商品i的调整后的期望收益(r_i-\gamma_i)\times{ctr}_{i\bar{h}}\times{cvr}_{i\bar{h}}进行从大到小的排序，最后对其推荐期望收益最大的K种商品。
	算法介绍
	算法流程图
 
	我们推荐系统的实现思路为首先输入基本的参数如顾客的种类数，商品种类数等等。第二步输入库存、本次推荐是今天的第几次、来的顾客是谁，根据这些参数进行线性规划的求解，得到各种商品的影子价格。第三步根据影子价格更新真实价格，并计算商品推荐值的大小，进行排序得到我们应该推荐的商品。
	类的定义
我们采用面向对象编程的思想。以下所有方法和属性均储存于在recomm()类中。
	初始化参数
在创建类时，我们便输入商品种类数、消费者种类数、一天的总交易次数、一次被展示的商品数量。以上这些决定模型的维数若需要更改，则需重新创建类。下一步需要通过recomm.initialize()函数进一步输入每一种消费者对每一种商品的点击率（ctr），转化率（cvr）。每一种消费者前来的概率。每一种商品的价格。我们根据以上信息生成每个消费者购买每种商品的概率矩阵。以上这些为模型中不会变的参数，只需执行一次即可完成定义。
	线性规划求解
为了求解每种商品的库存产生的影子价格，我们需要获得的实时信息有：每种商品即时的库存、本次交易为第几次交易（用于计算接下来还有几次交易）、这次来的客人是哪种（用于选择哪种推荐策略）。
输入以上信息后，执行recomm.LP(t,customer,invent),生成我们的模型所需的c、A、b的表达式，并调用Gurobi库进行规划求解，得到影子价格。
	计算分数推荐
我们得到了每种库存的影子价格后，recomm.sOrt()计算每种商品的真实价格并计算最后的推荐分数，排序后推荐前{待展示的数量}的商品。
注：我们的sOrt函数存放于LP函数中，在执行LP函数后自动执行，因为本次模型的计算量有限，考虑更好的收益时，我们直接每次交易均更新一次影子价格并推荐。当以后计算量增加，则可以执行一次LP后执行复数次sOrt。

